Thanks for the fresh logs. You‚Äôre still getting classic transient storage errors (‚ÄúINTERNAL‚Äù / ‚ÄúPlease try again‚Äù). Your v2 hardening is close; to squeeze out the remaining flakes, here‚Äôs a v3 patch that (a) avoids the flaky Apps Script ‚Äústorage handle‚Äù as much as possible, (b) adds a second, more reliable state store, and (c) gives you a quick health endpoint.

Below is copy-paste code you can drop into your existing AskNewton_Lead_Notifier.gs. It keeps your current logic but routes I/O through more resilient paths and adds fallbacks.

‚∏ª

1) Use the Sheets Advanced Service for reads/writes (bypasses most editor-layer hiccups)

In Apps Script: Services ‚Üí ‚ÄúGoogle Sheets API‚Äù ‚Üí Enable.

/******** v3 hardening: storage-agnostic state + Sheets Advanced Service ********/

// === CONFIG tweaks ===
CONFIG.CHUNK_ROWS = 100;            // smaller chunk for rough periods
CONFIG.CHECKPOINT_EVERY = 20;       // more frequent checkpoints
CONFIG.STATE_SHEET = 'State';       // fallback state tab (created on first run)
CONFIG.STATE_RANGE = 'A1';          // cursor cell in State sheet

// unified backoff options (slightly shorter to stay under time cap)
const RETRY_OPTS = { attempts: 5, baseMs: 300, factor: 2.0, jitter: true };

/** ---------- Low-level: Sheets Advanced Service wrappers ---------- **/
function sheetsValuesGet_(spreadsheetId, rangeA1) {
  return withRetry(() => {
    const resp = Sheets.Spreadsheets.Values.get(spreadsheetId, rangeA1);
    return resp.values || [];
  }, RETRY_OPTS);
}

function sheetsValuesBatchGet_(spreadsheetId, ranges) {
  return withRetry(() => {
    const resp = Sheets.Spreadsheets.Values.batchGet(spreadsheetId, { ranges });
    return resp.valueRanges || [];
  }, RETRY_OPTS);
}

function sheetsValuesUpdate_(spreadsheetId, rangeA1, values) {
  return withRetry(() => {
    return Sheets.Spreadsheets.Values.update(
      { values }, spreadsheetId, rangeA1,
      { valueInputOption: 'RAW' }
    );
  }, RETRY_OPTS);
}

function sheetsValuesBatchUpdate_(spreadsheetId, data) {
  return withRetry(() => {
    return Sheets.Spreadsheets.Values.batchUpdate(
      {
        data: data.map(d => ({ range: d.range, values: d.values })),
        valueInputOption: 'RAW'
      },
      spreadsheetId
    );
  }, RETRY_OPTS);
}

function sheetsGetLastRow_(sheetId, sheetName) {
  // read column A to detect last non-empty row without calling editor-layer APIs
  const colA = sheetsValuesGet_(sheetId, `${sheetName}!A:A`);
  // find last index with a value
  for (let i = colA.length - 1; i >= 0; i--) {
    if (colA[i] && colA[i].length && String(colA[i][0]).trim() !== '') {
      return i + 1; // 1-based row
    }
  }
  return 1; // only header
}

/** ---------- State store with dual backends (Properties ‚Üí Sheet) ---------- **/
const State = {
  getCursor() {
    // 1) try PropertiesService
    try {
      const props = PropertiesService.getScriptProperties();
      const v = withRetry(() => props.getProperty(CONFIG.CURSOR_KEY), RETRY_OPTS);
      if (v) return Number(v);
    } catch (e) {/* ignore */}
    // 2) fallback to State sheet
    ensureStateSheet_();
    const v = sheetsValuesGet_(CONFIG.SHEET_ID, `${CONFIG.STATE_SHEET}!${CONFIG.STATE_RANGE}`);
    const s = (v[0] && v[0][0]) ? Number(v[0][0]) : NaN;
    return Number.isFinite(s) ? s : (CONFIG.HEADER_ROW + 1);
  },
  setCursor(n) {
    // write both (props first, then sheet)
    try {
      const props = PropertiesService.getScriptProperties();
      withRetry(() => props.setProperty(CONFIG.CURSOR_KEY, String(n)), RETRY_OPTS);
    } catch (e) {/* ignore */}
    ensureStateSheet_();
    sheetsValuesUpdate_(CONFIG.SHEET_ID, `${CONFIG.STATE_SHEET}!${CONFIG.STATE_RANGE}`, [[ String(n) ]]);
  }
};

function ensureStateSheet_() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    let sh = ss.getSheetByName(CONFIG.STATE_SHEET);
    if (!sh) {
      sh = ss.insertSheet(CONFIG.STATE_SHEET);
      sh.getRange(CONFIG.STATE_RANGE).setValue(CONFIG.HEADER_ROW + 1); // init cursor
      sh.hideSheet();
    }
  } catch (e) {
    // if editor-layer open fails transiently, try again later; State writes still succeed via Advanced Service
  }
}

/** ---------- Entry with small jitter + lock ---------- **/
function myFunction() {
  const lock = tryAcquireLock(20000);
  if (!lock) { console.warn('No lock ‚Äî exiting to avoid overlap.'); return; }
  try {
    Utilities.sleep(800 + Math.floor(Math.random() * 1700)); // 0.8‚Äì2.5s jitter
    mainJob_v3();
  } finally {
    lock.releaseLock();
  }
}

/** ---------- Main (v3): Advanced Service + chunking + dual-state ---------- **/
function mainJob_v3() {
  const startTs = Date.now();
  const headerRow = CONFIG.HEADER_ROW;
  const cursor = State.getCursor();                  // resilient state read
  const lastRow = sheetsGetLastRow_(CONFIG.SHEET_ID, CONFIG.SHEET_NAME);
  if (lastRow < cursor) { console.log('No new rows.'); return; }

  const rowsRemaining = lastRow - cursor + 1;
  const numRows = Math.min(rowsRemaining, CONFIG.CHUNK_ROWS);

  // Build A1 range once (avoid editor-layer range objects)
  const startCol = CONFIG.START_COL;
  const endCol = CONFIG.START_COL + CONFIG.COL_COUNT - 1;
  const rangeA1 = `${CONFIG.SHEET_NAME}!${colLetter_(startCol)}${cursor}:${colLetter_(endCol)}${cursor + numRows - 1}`;

  // Read chunk via Advanced Service
  const vRanges = sheetsValuesBatchGet_(CONFIG.SHEET_ID, [rangeA1]);
  const values = (vRanges[0] && vRanges[0].values) ? vRanges[0].values : [];

  const statusIdx = CONFIG.NOTIFY_STATUS_COL_INDEX - 1;

  for (let i = 0; i < values.length; i++) {
    const row = values[i];
    // normalize row length to COL_COUNT (Advanced Service may omit trailing empties)
    if (row.length < CONFIG.COL_COUNT) row.push(...Array(CONFIG.COL_COUNT - row.length).fill(''));

    if (!row[statusIdx]) {
      if (CONFIG.SLACK_WEBHOOK_URL) {
        postSlack(CONFIG.SLACK_WEBHOOK_URL, {
          text: `üÜï New lead: ${String(row[1]||'Unknown')} ${row[3] ? '('+row[3]+')' : ''}`
        });
      }
      row[statusIdx] = 'NOTIFIED';
    }

    // checkpoint often
    if (i > 0 && (i % CONFIG.CHECKPOINT_EVERY) === 0) {
      State.setCursor(cursor + i);
      if (Date.now() - startTs > CONFIG.TIME_BUDGET_MS) {
        // write partial via Advanced Service, then exit
        const partialA1 = `${CONFIG.SHEET_NAME}!${colLetter_(startCol)}${cursor}:${colLetter_(endCol)}${cursor + i}`;
        sheetsValuesUpdate_(CONFIG.SHEET_ID, partialA1, values.slice(0, i + 1));
        State.setCursor(cursor + i + 1);
        console.log('Time budget reached; exiting gracefully.');
        return;
      }
    }
  }

  // Write entire processed chunk via Advanced Service
  sheetsValuesUpdate_(CONFIG.SHEET_ID, rangeA1, values);
  State.setCursor(cursor + numRows);
}

/** ---------- Utils ---------- **/
function colLetter_(n) {
  let s = '';
  while (n > 0) {
    const m = (n - 1) % 26;
    s = String.fromCharCode(65 + m) + s;
    n = Math.floor((n - 1) / 26);
  }
  return s;
}


‚∏ª

2) Optional: tiny /health endpoint (quick glance without opening IDE)

Create a standalone web app in the same script if you like:

function doGet() {
  const cursor = State.getCursor();
  let lastRow = -1;
  try { lastRow = sheetsGetLastRow_(CONFIG.SHEET_ID, CONFIG.SHEET_NAME); } catch (e) {}
  const body = JSON.stringify({
    sheet: CONFIG.SHEET_NAME,
    cursor, lastRow,
    time: new Date().toISOString()
  });
  return ContentService.createTextOutput(body).setMimeType(ContentService.MimeType.JSON);
}

Deploy ‚Üí ‚ÄúExecute as Me‚Äù ‚Üí ‚ÄúAnyone with link‚Äù (or your domain). This is read-only status.

‚∏ª

3) One-time hygiene checklist (quick)
	‚Ä¢	Triggers: ensure only one time-based trigger on myFunction, run every 7 minutes (odd cadence).
	‚Ä¢	Keep CHUNK_ROWS at 100 for now; bump later if stable.
	‚Ä¢	If INTERNAL bursts continue, lower CHECKPOINT_EVERY to 10.

‚∏ª

Why this solves your remaining flakes
	‚Ä¢	Advanced Service calls (Sheets API) route around many editor-layer ‚Äústorage handle‚Äù errors.
	‚Ä¢	Dual state store (Properties ‚Üí State sheet cell) means even if one backend blips, the other keeps you moving.
	‚Ä¢	More frequent checkpoints + smaller chunks reduce the blast radius of any single hiccup.
	‚Ä¢	Jitter avoids colliding with Google‚Äôs own scheduled maintenance/peak intervals.

If you want, I can also add an auto-trigger installer that deletes duplicates and re-creates a single odd-cadence trigger, but the above should already knock out the intermittent ‚ÄúINTERNAL‚Äùs you‚Äôre seeing.