Goal

Enhance asknewton-webhooks with:

/events/ui â€“ HTML table (search/sort/filter), color-coded types

/metrics â€“ Prometheus-format counters

/events/replay/:id â€“ safely re-run your own processing on a stored event

1) package.json (add static serving, no new deps required)

No change needed if you already have:

{
  "name": "asknewton-webhooks",
  "version": "1.1.0",
  "type": "module",
  "private": true,
  "scripts": { "start": "node server.js", "dev": "NODE_ENV=development node server.js" },
  "dependencies": { "express": "^4.19.2", "node-fetch": "^3.3.2" }
}

2) Update server.js

Replace your current server.js with this upgraded version (keeps your Slack + HMAC + idempotency exactly as before, and adds UI/metrics/replay):

import express from "express";
import crypto from "crypto";
import fetch from "node-fetch";
import path from "path";
import { fileURLToPath } from "url";

const app = express();
const PORT = process.env.PORT || 3000;
const MAX_EVENTS = 200;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// --- Slack Alert ---
async function sendSlackAlert(message) {
  const webhook = process.env.SLACK_WEBHOOK_URL;
  if (!webhook) return;
  try {
    await fetch(webhook, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: message })
    });
  } catch (err) {
    console.error("Slack alert failed:", err.message);
  }
}

// --- Raw body for HMAC ---
app.use(express.json({
  limit: "1mb",
  verify: (req, _res, buf) => { req.rawBody = buf; }
}));

// --- Static assets for UI ---
app.use("/public", express.static(path.join(__dirname, "public")));

// --- In-memory store & metrics ---
const seenIds = new Set();
const events = []; // {id,type,ts,path,body}
const metrics = {
  events_total: 0,
  duplicates_total: 0,
  invalid_signature_total: 0,
  errors_total: 0
};

function recordEvent({ id, type, path, body }) {
  const ts = new Date().toISOString();
  events.unshift({ id, type, ts, path, body });
  metrics.events_total++;
  if (events.length > MAX_EVENTS) events.pop();
}

const SIG_HEADERS = [
  "x-elevenlabs-signature",
  "x-signature",
  "x-webhook-signature",
  "x-hub-signature"
];

function getSignatureHeader(req) {
  return SIG_HEADERS.map(h => req.get(h)).find(Boolean) || "";
}

function verifyHmac(req, secret) {
  const sigHeader = getSignatureHeader(req);
  const computed = crypto
    .createHmac("sha256", secret)
    .update(req.rawBody || Buffer.from(""))
    .digest("hex");
  try {
    return crypto.timingSafeEqual(Buffer.from(computed), Buffer.from(sigHeader));
  } catch {
    return false;
  }
}

function guard(secretEnvKey) {
  return (req, res, next) => {
    const secret = process.env[secretEnvKey];
    if (!secret) {
      sendSlackAlert(`ðŸš¨ Missing secret: ${secretEnvKey}`);
      metrics.errors_total++;
      return res.status(500).json({ ok: false, error: `${secretEnvKey} missing` });
    }
    if (!verifyHmac(req, secret)) {
      sendSlackAlert(`âš ï¸ Invalid signature on ${req.path}`);
      metrics.invalid_signature_total++;
      return res.status(401).json({ ok: false, error: "Invalid signature" });
    }
    next();
  };
}

function idempotency(req, res, next) {
  const id = req.body?.id || req.body?.event_id;
  if (!id) return next();
  if (seenIds.has(id)) {
    metrics.duplicates_total++;
    return res.json({ ok: true, duplicate: true });
  }
  seenIds.add(id);
  next();
}

// --- Your business processing stub (extend as needed) ---
async function processEvent({ type, body }) {
  // TODO: push to queue, call your app, etc.
  // Keep this fast; do heavy work async.
  return { processed: true, type };
}

// --- Webhooks ---
app.post("/webhooks/eleven/conversation-init",
  guard("ELEVEN_INIT_SECRET"),
  idempotency,
  async (req, res) => {
    const id = req.body?.id || req.body?.event_id || `init-${Date.now()}`;
    recordEvent({ id, type: "conversation-init", path: req.path, body: req.body });
    // fire-and-forget processing
    processEvent({ type: "conversation-init", body: req.body }).catch(err => {
      metrics.errors_total++; sendSlackAlert(`ðŸ”¥ Processing error (init): ${err.message}`);
    });
    res.json({ ok: true });
  }
);

app.post("/webhooks/eleven/conversation-end",
  guard("ELEVEN_END_SECRET"),
  idempotency,
  async (req, res) => {
    const id = req.body?.id || req.body?.event_id || `end-${Date.now()}`;
    recordEvent({ id, type: "conversation-end", path: req.path, body: req.body });
    processEvent({ type: "conversation-end", body: req.body }).catch(err => {
      metrics.errors_total++; sendSlackAlert(`ðŸ”¥ Processing error (end): ${err.message}`);
    });
    res.json({ ok: true });
  }
);

// --- Health / Version ---
app.get("/healthz", (_req, res) => res.json({ ok: true, service: "asknewton-webhooks" }));
app.get("/version", (_req, res) => res.json({ version: "1.1.0" }));

// --- JSON Events API (with basic filtering) ---
app.get("/events", (req, res) => {
  const { type, q, limit = "100" } = req.query;
  let list = events;
  if (type) list = list.filter(e => e.type === String(type));
  if (q) {
    const s = String(q).toLowerCase();
    list = list.filter(e =>
      e.id.toLowerCase().includes(s) ||
      e.type.toLowerCase().includes(s) ||
      JSON.stringify(e.body ?? {}).toLowerCase().includes(s)
    );
  }
  const n = Math.min(parseInt(String(limit), 10) || 100, 500);
  const trimmed = list.slice(0, n).map(e => ({
    id: e.id, type: e.type, ts: e.ts, path: e.path,
    body_preview: JSON.stringify(e.body ?? {}).slice(0, 1200)
  }));
  res.json({ count: trimmed.length, items: trimmed });
});

// --- Pretty UI for Events ---
app.get("/events/ui", (_req, res) => {
  res.sendFile(path.join(__dirname, "public", "events.html"));
});

// --- Replay an event by id (reprocess in-process only) ---
app.post("/events/replay/:id", async (req, res) => {
  const { id } = req.params;
  const evt = events.find(e => e.id === id);
  if (!evt) return res.status(404).json({ ok: false, error: "Not found" });
  try {
    const result = await processEvent({ type: evt.type, body: evt.body });
    res.json({ ok: true, replayed: id, result });
  } catch (err) {
    metrics.errors_total++; sendSlackAlert(`ðŸ”¥ Replay error ${id}: ${err.message}`);
    res.status(500).json({ ok: false, error: err.message });
  }
});

// --- Prometheus metrics ---
app.get("/metrics", (_req, res) => {
  res.type("text/plain").send(
    [
      "# HELP asknewton_events_total Total accepted events",
      "# TYPE asknewton_events_total counter",
      `asknewton_events_total ${metrics.events_total}`,
      "# HELP asknewton_duplicates_total Total duplicate events",
      "# TYPE asknewton_duplicates_total counter",
      `asknewton_duplicates_total ${metrics.duplicates_total}`,
      "# HELP asknewton_invalid_signature_total Invalid signature attempts",
      "# TYPE asknewton_invalid_signature_total counter",
      `asknewton_invalid_signature_total ${metrics.invalid_signature_total}`,
      "# HELP asknewton_errors_total Processing/server errors",
      "# TYPE asknewton_errors_total counter",
      `asknewton_errors_total ${metrics.errors_total}`
    ].join("\n")
  );
});

// --- Error handler ---
app.use((err, req, res, _next) => {
  console.error("Unhandled error:", err);
  metrics.errors_total++;
  sendSlackAlert(`ðŸ”¥ Error on ${req.path}: ${err.message}`);
  res.status(500).json({ ok: false, error: "Server error" });
});

app.listen(PORT, () => {
  console.log(`asknewton-webhooks listening on :${PORT}`);
});

3) Add UI files

Create folder: public/

public/events.html

<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AskNewton Webhooks â€” Events</title>
  <link rel="stylesheet" href="/public/events.css" />
</head>
<body>
  <header>
    <h1>AskNewton Webhooks â€” Events</h1>
    <nav>
      <a href="/healthz" target="_blank">healthz</a>
      <a href="/version" target="_blank">version</a>
      <a href="/metrics" target="_blank">metrics</a>
      <a href="/events" target="_blank">events.json</a>
    </nav>
  </header>

  <section class="controls">
    <input id="search" placeholder="Search id/type/bodyâ€¦" />
    <select id="type">
      <option value="">All types</option>
      <option value="conversation-init">conversation-init</option>
      <option value="conversation-end">conversation-end</option>
    </select>
    <button id="refresh">Refresh</button>
  </section>

  <table id="tbl">
    <thead>
      <tr>
        <th>ID</th><th>Type</th><th>Time (UTC)</th><th>Path</th><th>Body (preview)</th><th>Replay</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script src="/public/events.js"></script>
</body>
</html>


public/events.css

* { box-sizing: border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
body { margin: 20px; }
header { display: flex; align-items: baseline; gap: 20px; }
nav a { margin-right: 12px; text-decoration: none; color: #0366d6; }
.controls { margin: 16px 0; display: flex; gap: 10px; }
#search { width: 320px; padding: 8px; }
select, button { padding: 8px; }
table { width: 100%; border-collapse: collapse; }
thead { background: #f3f4f6; }
th, td { padding: 10px; border-bottom: 1px solid #e5e7eb; vertical-align: top; }
tbody tr:hover { background: #f9fafb; }
.badge { padding: 2px 8px; border-radius: 999px; font-size: 12px; color: #111827; }
.badge.init { background: #d1fae5; }       /* green */
.badge.end  { background: #dbEafe; }       /* blue */
.replay-btn { padding: 6px 10px; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; background: #fff; }
.replay-btn:hover { background: #f3f4f6; }


public/events.js

async function fetchEvents() {
  const q = document.getElementById("search").value.trim();
  const type = document.getElementById("type").value;
  const params = new URLSearchParams();
  if (q) params.set("q", q);
  if (type) params.set("type", type);
  params.set("limit", "200");
  const res = await fetch(`/events?${params.toString()}`);
  const data = await res.json();
  return data.items || [];
}

function badge(type) {
  const span = document.createElement("span");
  span.className = "badge " + (type === "conversation-init" ? "init" : "end");
  span.textContent = type;
  return span;
}

async function replay(id) {
  const btn = document.querySelector(`button[data-id="${id}"]`);
  btn.disabled = true;
  btn.textContent = "Replayingâ€¦";
  try {
    const res = await fetch(`/events/replay/${encodeURIComponent(id)}`, { method: "POST" });
    const data = await res.json();
    btn.textContent = data.ok ? "Replayed" : "Failed";
  } catch {
    btn.textContent = "Error";
  } finally {
    setTimeout(() => { btn.disabled = false; btn.textContent = "Replay"; }, 1200);
  }
}

async function render() {
  const tbody = document.querySelector("#tbl tbody");
  tbody.innerHTML = "";
  const items = await fetchEvents();
  for (const e of items) {
    const tr = document.createElement("tr");

    const tdId = document.createElement("td"); tdId.textContent = e.id;
    const tdType = document.createElement("td"); tdType.appendChild(badge(e.type));
    const tdTs = document.createElement("td"); tdTs.textContent = e.ts;
    const tdPath = document.createElement("td"); tdPath.textContent = e.path;
    const tdBody = document.createElement("td"); tdBody.textContent = e.body_preview || "";
    const tdReplay = document.createElement("td");
    const btn = document.createElement("button");
    btn.className = "replay-btn";
    btn.textContent = "Replay";
    btn.dataset.id = e.id;
    btn.onclick = () => replay(e.id);
    tdReplay.appendChild(btn);

    tr.append(tdId, tdType, tdTs, tdPath, tdBody, tdReplay);
    tbody.appendChild(tr);
  }
}

document.getElementById("refresh").onclick = render;
document.getElementById("search").oninput = () => { clearTimeout(window.__t); window.__t = setTimeout(render, 250); };
document.getElementById("type").onchange = render;

// auto-refresh every 10s
setInterval(render, 10000);
render();

4) Run
npm install
npm start


Open:

UI: /events/ui

JSON: /events?limit=50

Metrics: /metrics

Your Slack alerts continue to fire on missing secrets, invalid signatures, and unhandled errors. Replay safely re-invokes your local processEvent logic without calling ElevenLabs.